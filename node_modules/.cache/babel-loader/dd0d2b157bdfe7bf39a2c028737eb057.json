{"ast":null,"code":"import { Combination } from \"js-combinatorics\";\nconst keys = [2, 7, 6, 9, 5, 1, 4, 3, 8, 10, 11, 12, 13, 14, 15, 16];\n\n// get every unique combination of 3 numbers and only keep the ones that sum to 15\n// I'll explain why this works later.\nconst winningCombos = new Combination(keys, 4).toArray().filter(nums => nums.reduce((acc, num) => acc + num) === 34);\nconst hasWinner = grid => winningCombos\n// get the corresponding grid items\n.map(combo => combo.map(key => grid[key]))\n// if you find at least one with all Xs or all Os, there's a winner!\n.some(comboValues => comboValues.every(v => v === \"X\") || comboValues.every(v => v === \"O\"));\nexport default class Game {\n  constructor() {\n    this._grid = void 0;\n    this.getCell = key => key in this._grid ? this._grid[key] : null;\n    this.setCell = key => {\n      // no winner yet, a valid name and an empty cell? Set grid cell to whoever's turn this is.\n      if (!this.winner && key in this._grid && !this._grid[key]) this._grid[key] = this.turn;\n    };\n    // using reduce to add all our keys to an object with initial values of null;\n    this._grid = keys.reduce((grid, key) => Object.assign(grid, {\n      [key]: null\n    }), {});\n  }\n  get turn() {\n    // get the grid values\n    const counts = Object.values(this._grid)\n    // use reduce to make an object that counts all the Xs and Os\n    .reduce((acc, value) => {\n      if (value === \"X\") acc.Xs += 1;else if (value === \"O\") acc.Os += 1;\n      return acc;\n    }, {\n      Xs: 0,\n      Os: 0\n    });\n    // if there are more Xs on the board, it's O's turn.\n    return counts.Xs > counts.Os ? \"O\" : \"X\";\n  }\n  get winner() {\n    if (!hasWinner(this._grid)) return null;\n    // if there's a winner and it's X's turn, that means O just won. Otherwise, X just won.\n    else return this.turn === \"X\" ? \"O\" : \"X\";\n  }\n  get isFull() {\n    // no null values in the grid? board must be full\n    return Object.entries(this._grid).every(_ref => {\n      let [_, value] = _ref;\n      return !!value;\n    });\n  }\n  get cellNames() {\n    return keys;\n  }\n}","map":{"version":3,"names":["Combination","keys","winningCombos","toArray","filter","nums","reduce","acc","num","hasWinner","grid","map","combo","key","some","comboValues","every","v","Game","constructor","_grid","getCell","setCell","winner","turn","Object","assign","counts","values","value","Xs","Os","isFull","entries","_ref","_","cellNames"],"sources":["/Users/thomaskonan/Desktop/Actualize/ReactTicTacToe/src/GameClass.ts"],"sourcesContent":["import { Combination } from \"js-combinatorics\";\n\ntype Grid = { [key: number]: \"X\" | \"O\" | null };\n\nconst keys = [2, 7, 6, 9, 5, 1, 4, 3, 8, 10, 11, 12, 13, 14, 15, 16];\n\n// get every unique combination of 3 numbers and only keep the ones that sum to 15\n// I'll explain why this works later.\nconst winningCombos = new Combination(keys, 4).toArray().filter(\n  (nums) => nums.reduce((acc, num) => acc + num) === 34\n);\n\nconst hasWinner = (grid: Grid) =>\n  winningCombos\n    // get the corresponding grid items\n    .map((combo) => combo.map((key) => grid[key]))\n    // if you find at least one with all Xs or all Os, there's a winner!\n    .some(\n      (comboValues) =>\n        comboValues.every((v) => v === \"X\") ||\n        comboValues.every((v) => v === \"O\")\n    );\n\nexport default class Game {\n  private _grid: Grid;\n\n  constructor() {\n    // using reduce to add all our keys to an object with initial values of null;\n    this._grid = keys.reduce(\n      (grid, key) => Object.assign(grid, { [key]: null }),\n      {}\n    );\n  }\n\n  get turn() {\n    // get the grid values\n    const counts = Object.values(this._grid)\n      // use reduce to make an object that counts all the Xs and Os\n      .reduce(\n        (acc, value) => {\n          if (value === \"X\") acc.Xs += 1;\n          else if (value === \"O\") acc.Os += 1;\n          return acc;\n        },\n        { Xs: 0, Os: 0 }\n      );\n    // if there are more Xs on the board, it's O's turn.\n    return counts.Xs > counts.Os ? \"O\" : \"X\";\n  }\n\n  get winner() {\n    if (!hasWinner(this._grid)) return null;\n    // if there's a winner and it's X's turn, that means O just won. Otherwise, X just won.\n    else return this.turn === \"X\" ? \"O\" : \"X\";\n  }\n\n  get isFull() {\n    // no null values in the grid? board must be full\n    return Object.entries(this._grid).every(([_, value]) => !!value);\n  }\n\n  getCell = (key: number) => (key in this._grid ? this._grid[key] : null);\n\n  setCell = (key: number) => {\n    // no winner yet, a valid name and an empty cell? Set grid cell to whoever's turn this is.\n    if (!this.winner && key in this._grid && !this._grid[key])\n      this._grid[key] = this.turn;\n  };\n\n  get cellNames() {\n    return keys;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}